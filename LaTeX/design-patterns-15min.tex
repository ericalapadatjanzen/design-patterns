% $Header$

\documentclass{beamer}

\usetheme{Darmstadt}

\usepackage[english]{babel}
\usepackage[latin1]{inputenc}
\usepackage{listings}
\usepackage{textcomp}

% TypeScript Code Listings
% Taken from Lena Herrmann at 
% http://lenaherrmann.net/2010/05/20/javascript-syntax-highlighting-in-the-latex-listings-package
\usepackage{color}
\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}

\lstdefinelanguage{TypeScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{
   language=TypeScript,
   backgroundcolor=\color{white},
   extendedchars=true,
   basicstyle=\tiny\ttfamily,
   showstringspaces=false,
   showspaces=false,
   tabsize=2,
   breaklines=true,
   showtabs=false,
   captionpos=b
}
% ------ End 

% https://www.sharelatex.com/learn/Inserting_Images
\usepackage{graphicx}
\graphicspath{ {images/} }

\title{Design Principles}
\subtitle{aka Object Oriented Programming}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}{Why?}

    \begin{itemize}
        \item Allow change without redesign.
        \item Allow reuse in other applications.
    \end{itemize}

\end{frame}

\begin{frame}{Encapsulate what varies.}
    \begin{itemize}
        \item Encapsulate \ldots
            \begin{itemize}
                \item Restrict outside access to a things parts.
                \item Bundle operations with the things they use.
            \end{itemize}
        \item \ldots what varies.
            \begin{itemize}
                \item This refers to source code.
                \item Source code varies due to changing requirements.
                \item Requirements change for a lots of reasons.
                \item E.g. A change in government may cause a change in tax law.
            \end{itemize}
        \item Restrict outside access to parts of the source code that might change due to changing requirements.
        \item ``what [do] you want to be \textit{able} to change without redesign?'' (Gamma et al, 1977)
    \end{itemize}
\end{frame}

\begin{frame}{Encapsulate what varies \ldots}
    \begin{columns}
        \column{\dimexpr\paperwidth-40pt}
        \lstinputlisting{src/simple/encapsulate-what-varies.ts}
    \end{columns}
\end{frame}

\begin{frame}{Program to interfaces not to implementations.}
    \begin{itemize}
        \item an interface says only what requests it will receive
        \item an implementation says how it will handle those requests
        \item programming to interfaces helps because it
            \begin{itemize}
                \item lets us easily change an implementation, even at runtime
                \item allows applications to send the same request to different classes
            \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}{Program to interfaces \ldots}
    \begin{columns}
        \column{\dimexpr\paperwidth-40pt}
        \lstinputlisting{src/simple/program-to-interfaces.ts}
    \end{columns}
\end{frame}

\begin{frame}{Depend on abstractions not on concrete classes.}
    \begin{itemize}
        \item interfaces and abstractions are similar: neither can exist
        \item concrete classes can exist (i.e. can become objects)
        \item to depend on something means a direct reference to it
        \item The Dependency Inversion Principle (Martin, 1996)
        \begin{itemize}
            \item Traditionally, high-level modules depend on low-level modules:
            \item Higher \textrightarrow{} Middle \textrightarrow{} Lower \textrightarrow{} ...
            \item Dependency Inversion inverts that:
            \item Higher \textrightarrow{} Abstraction \textleftarrow{} Middle \textrightarrow{} Abstraction \textleftarrow{} Lower ...
        \end{itemize}
        \item When layering, higher-levels define the abstractions
        \item and lower-levels implement the abstractions.
        \item Why? Enable reuse of higher-level modules.
    \end{itemize}
\end{frame}

\begin{frame}{Depend on abstractions \ldots}
    \vspace{0cm}
    \begin{columns}
        \column{\dimexpr\paperwidth-40pt}
        \lstinputlisting{src/simple/depend-on-abstractions.ts}
    \end{columns}
\end{frame}

\begin{frame}{Only talk to your friends.}
    \begin{itemize}
        \item The Law of Demeter (Holland, 1987)
        \item The Princple of Least Knowledge
        \begin{itemize}
            \item
            \item
            \item
            \item
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}{Only talk to your friends \ldots}
    \vspace{0cm}
    \begin{columns}
        \column{\dimexpr\paperwidth-40pt}
        \lstinputlisting{src/simple/only-talk-to-your-friends.ts}
    \end{columns}
\end{frame}

\begin{frame}{Don't call us, we'll call you.}
    \begin{itemize}
        \item Inversion of Control
    \end{itemize}
\end{frame}

\begin{frame}{A class should have only one reason to change.}
    \begin{itemize}
        \item The Single Responsibility Principle ()
    \end{itemize}
\end{frame}

\begin{frame}{Classes should be open to extension and closed for modification.}
    \begin{itemize}
        \item The Open-Closed Principle ()
    \end{itemize}
\end{frame}

\begin{frame}{Favour composition over inheritance.}
    \begin{itemize}
        \item The Liskov Substitution Principle ()
    \end{itemize}
\end{frame}

\begin{frame}{Strive for loosely coupled designs among objects that interact.}
    \begin{itemize}
        \item
    \end{itemize}
\end{frame}

\end{document}

