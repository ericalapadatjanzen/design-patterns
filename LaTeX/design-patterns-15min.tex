% $Header$

\documentclass{beamer}

\usetheme{Darmstadt}

\usepackage[english]{babel}
\usepackage[latin1]{inputenc}
\usepackage{times}
\usepackage{listings}

\lstset{
    % https://tex.stackexchange.com/a/34690/137042
    basicstyle=\fontfamily{pcr}\tiny\color{yellow},
    backgroundcolor=\color{black},
    frame=single
}

% https://www.sharelatex.com/learn/Inserting_Images
\usepackage{graphicx}
\graphicspath{ {images/} }

\title{Design Patterns}
\subtitle{aka Object Oriented Programming}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}{Program to interfaces not to implementations.}
    \begin{itemize}
        \item an interface says only what requests it will receive
        \item an implementation says how it will handle those requests
        \item programming to interfaces helps because it
            \begin{itemize}
                \item lets us easily change an implementation, even at runtime
                \item allows applications to send the same request to different classes
            \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}{}
    \lstinputlisting{src/simple/program-to-interfaces.ts}
\end{frame}

\begin{frame}{Depend on abstractions not on concrete classes.}
    \begin{itemize}
        \item interfaces and abstractions are similar: neither can exist
        \item concrete classes can exist (i.e. can become objects)
        \item to depend on something means a direct reference to it
        \item The Dependency Inversion Principle (Martin, 1996)
        \begin{itemize}
            \item Traditionally, high-level modules depend on low-level modules:
            \item `Higher` ---> `Middle` ---> `Lower` ---> ...
            \item Dependency Inversion inverts that:
            \item `Higher` ---> `Abstraction` <--- `Middle` ---> `Abstraction` <--- `Lower` ...
        \end{itemize}
        \item When layering, higher-levels define the abstractions
        \item and lower-levels implement the abstractions.
    \end{itemize}
\end{frame}

\begin{frame}{}
    \lstinputlisting{src/simple/depend-on-abstractions.ts}
\end{frame}

\begin{frame}{A class should have only one reason to change.}
    \begin{itemize}
        \item
    \end{itemize}
\end{frame}

\begin{frame}{Classes should be open to extension and closed for modification.}
    \begin{itemize}
        \item
    \end{itemize}
\end{frame}

\begin{frame}{Depend on abstractions not on concrete classes.}
    \begin{itemize}
        \item
    \end{itemize}
\end{frame}

\begin{frame}{Don't call us, we'll call you.}
    \begin{itemize}
        \item
    \end{itemize}
\end{frame}

\begin{frame}{Encapsulate what varies.}
    \begin{itemize}
        \item
    \end{itemize}
\end{frame}

\begin{frame}{Favour composition over inheritance.}
    \begin{itemize}
        \item
    \end{itemize}
\end{frame}

\begin{frame}{Only talk to your friends.}
    \begin{itemize}
        \item
    \end{itemize}
\end{frame}

\begin{frame}{Strive for loosely coupled designs among objects that interact.}
    \begin{itemize}
        \item
    \end{itemize}
\end{frame}

\end{document}

