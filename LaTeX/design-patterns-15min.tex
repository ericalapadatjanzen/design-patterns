% $Header$

\documentclass{beamer}

\usetheme{Darmstadt}

\usepackage[english]{babel}
\usepackage[latin1]{inputenc}
\usepackage{textcomp}


% https://www.sharelatex.com/learn/Inserting_Images
\usepackage{graphicx}
\graphicspath{ {images/} }

\title{Design Principles}
\subtitle{aka Object Oriented Programming}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}{Why?}

    \begin{itemize}
        \item Allow change (of system capacities) without redesign.
        \item Allow reuse in other applications.
    \end{itemize}

\end{frame}

\begin{frame}{Encapsulate what varies.}
    \begin{itemize}
        \item Encapsulate \ldots
            \begin{itemize}
                \item Restrict outside access to a thing's parts.
                \item Bundle operations with the things they use.
            \end{itemize}
        \item \ldots what varies.
            \begin{itemize}
                \item This refers to changes to source code.
                \item Source code changes due to changing requirements.
                \item Requirements change for a lots of reasons.
                \item E.g. A change in government may cause a change in tax law.
            \end{itemize}
        \item Restrict outside access to parts of the source code that might change due to changing requirements.
        \item ``what [do] you want to be \textit{able} to change without redesign?'' (Gamma et al, 1977)
    \end{itemize}
\end{frame}

\begin{frame}{Program to interfaces not to implementations.}
    \begin{itemize}
        \item an interface says only what requests it will receive
        \item an implementation says how it will handle those requests
        \item programming to interfaces helps because it
            \begin{itemize}
                \item lets us easily change an implementation, even at runtime
                \item allows applications to send the same request to different classes
            \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}{Depend on abstractions not on concrete classes.}
    \begin{itemize}
        \item interfaces and abstractions are similar: neither can exist
        \item concrete classes can exist (i.e. can become objects)
        \item to depend on something means a direct reference to it
        \item The Dependency Inversion Principle (Martin, 1996)
        \begin{itemize}
            \item Traditionally, high-level modules depend on low-level modules:
            \item Higher \textrightarrow{} Middle \textrightarrow{} Lower \textrightarrow{} ...
            \item Dependency Inversion inverts that:
            \item Higher \textrightarrow{} Abstraction \textleftarrow{} Middle \textrightarrow{} Abstraction \textleftarrow{} Lower ...
        \end{itemize}
        \item When layering, higher-levels define the abstractions
        \item and lower-levels implement the abstractions.
        \item Why? Enable reuse of higher-level modules.
    \end{itemize}
\end{frame}

\begin{frame}{Only talk to your friends.}
    \begin{itemize}
        \item The Law of Demeter (Holland, 1987)
        \item aka The Princple of Least Knowledge
        \item Why? Promotes loose coupling via encapsulation.
        \item ``Only talk to your friends''
        \item ``Only use one dot'' 
            \begin{itemize}
                \item More than one dot is cause for reflection; 
                \item it is not necessarily a violation of the LoD.
                \item E.g. fluent interfaces use many dots.
            \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}{A class should have only one reason to change.}
    \begin{itemize}
        \item The Single Responsibility Principle (Martin, 2003)
        \item ``A class should have only one reason to change''
        \begin{itemize}
            \item Recall from ``encapsulate what varies.''
            \item This refers to changes to source code.
            \item Source code changes due to changing requirements.
        \end{itemize}
    \item Why? 
        \begin{itemize}
            \item (Re)use feature X without bringing feature A-Z.
            \item Change feature X without breaking/recompiling what depends on feature A-Z.
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}{Don't call us, we'll call you.}
    \begin{itemize}
        \item "Hollywood Principle" (Sweet, 1983)
        \item "Inversion of Control" (Johnson and Foote, 1988)
            \begin{itemize}
                \item Dependency injection is a type of Inversion of Control
                \item IoC containers are a type of Dependency Injection
            \end{itemize}
        \item Dependency Inversion - who owns the abstraction?
        \item Inversion of Control - when do things happen?
        \item "coordinating and sequencing application activity"         
        \item "makes a framework different from a library":
            \begin{itemize}
                \item library: "a set of functions you can call"
                \item framework: "insert your behavior into various places"
            \end{itemize}
        \item How? subclassing, implementing iterfaces, binding/events
    \end{itemize}
\end{frame}

\begin{frame}{Classes should be open to extension and closed for modification.}
    \begin{itemize}
        \item The Open-Closed Principle (TODO)
        \item Source code that people are using is sacrosanct.
    \end{itemize}
\end{frame}

\begin{frame}{Favour composition over inheritance.}
    \begin{itemize}
        \item The Liskov Substitution Principle (TODO)
    \end{itemize}
\end{frame}

\begin{frame}{Strive for loosely coupled designs among objects that interact.}
    \begin{itemize}
        \item This is the summary statement for all the princples.
        \item When loosely coupled, we can...
        \item change X without needing to change Y, and
        \item use X without needing to bring along Y.
    \end{itemize}
\end{frame}

\end{document}

